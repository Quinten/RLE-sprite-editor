<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>RLE sprite editor</title>
    <meta name="description" content="Editor and converter for Run Length Encoded sprites">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="teal">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body { height: 100%; position: relative; overflow: hidden; background: teal; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        canvas { position: relative; display: block; }
    </style>
</head>
<body>
<script>

let canvas = document.createElement('canvas');
document.body.appendChild(canvas);

// the 2d drawing api
let ctx = canvas.getContext('2d');
//console.log(ctx);

// resize canvas with window
let w;
let h;
let resizeTOID = 0;
let onR = e => {
    clearTimeout(resizeTOID);
    resizeTOID = setTimeout(_ => {
        canvas.width = w = window.innerWidth * window.devicePixelRatio;
        canvas.height = h = window.innerHeight * window.devicePixelRatio;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
    }, 40);
};
onR();
window.addEventListener('resize', onR);

// init
let u = 48 * window.devicePixelRatio;
let shapeVisible = true;
let shapes = [
    time => {
        ctx.rotate(Math.PI * time / 1000);
        ctx.fillStyle = (shapeVisible) ? 'snow' : 'turquoise';
        ctx.fillRect(-u / 2, - u / 2, u, u);
    }
];

let blocks = [];
blocks.push({
    x: 0,
    y: 0,
    shape: 0
});

// animation loop
let onF = time => {

    // clear canvas
    ctx.save();
    ctx.fillStyle = 'teal';
    ctx.fillRect(0, 0, w, h);
    ctx.restore();

    // draw stuff
    blocks.forEach(block => {
        if (block === undefined) {
            return;
        }
        ctx.save();
        ctx.translate(w / 2 + block.x, h / 2 + block.y);
        shapes[block.shape](time);
        ctx.restore();
    });

    // request next frame
    requestAnimationFrame(onF);
};
setTimeout(onF, 50, 0);

// pointer events
// mousedown | mousemove | mouseup
// touchstart | touchmove | touchend

canvas.addEventListener('mousedown', e => {

    let pointerX = e.clientX * window.devicePixelRatio;
    let pointerY = e.clientY * window.devicePixelRatio;

    handlePointer(pointerX, pointerY);
});

canvas.addEventListener('touchstart', e => {

    e.preventDefault(); // this prevents the mousedown from firing

    let pointerX = e.changedTouches[0].clientX * window.devicePixelRatio;
    let pointerY = e.changedTouches[0].clientY * window.devicePixelRatio;

    handlePointer(pointerX, pointerY);
});

let handlePointer = (pointerX, pointerY) => {

    let index = blocks.findIndex(block => {
        if (block === undefined) {
            return false;
        }
        let x = w / 2 + block.x - u / 2;
        let y = h / 2 + block.y - u / 2;
        return !(pointerX < x || pointerY < y || pointerX > x + u || pointerY > y + u);
    });
    if (index > -1) {
        if (blocks[index] !== undefined) {
            shapeVisible = !shapeVisible;
        }
    }
};

// register service worker for PWA
if ('serviceWorker' in navigator) {
    window.addEventListener('load', e => {
        navigator.serviceWorker.register('./sw.js').then(registration => {
            //console.log('ServiceWorker registration successful with scope: ', registration.scope);
        }, err => {
            //console.log('ServiceWorker registration failed: ', err);
        });
    });
}

</script>
</body>
</html>
