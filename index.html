<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>RLE sprite editor</title>
    <meta name="description" content="Editor and converter for Run Length Encoded sprites">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#282828">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        html, body { height: 100%; position: relative; overflow-x: hidden; }
        body { font-family: sans-serif; background: #282828; color: white; }
        * { margin: 0; padding: 0; box-sizing: border-box; font-size: 1rem; text-align: center; }
        canvas { image-rendering: pixelated; background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAJ0lEQVQoU2N89+7dfwYkICgoiMxlYKSDgv///6O44f3796huoL0CAPpyKx1ry0n4AAAAAElFTkSuQmCC') repeat top left; }
        button { height: 3rem; padding: 0 1rem; vertical-align: middle; background: white; border: 0; border-radius: 1.5rem; min-width: 3rem; line-height: 3rem; }
        .block { display: block; margin: 1rem auto; }
        input { vertical-align: middle; background: white; box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.5); border: 0; border-radius: .25em; height: 3rem; width: calc(100% - 2rem); max-width: 16rem; }
        input.small { max-width: 3rem; }
        input.medium { max-width: 8rem; }
        input:disabled { background: #828282; }
    </style>
</head>
<body>
<canvas id="canvas" class="block"></canvas>
<div class="block">
    <button title="Play animation" onclick="playing = true;">&rtrif;</button>
    <button title="Pause animation" onclick="playing = false;">&FilledSmallSquare;</button>
    <button title="Previous frame" onclick="playing = false; data.currentFrame = (data.currentFrame - 1 + data.frames.split('|').length) % data.frames.split('|').length;">&laquo;</button>
    <button title="Next frame" onclick="playing = false; data.currentFrame = (data.currentFrame + 1) % data.frames.split('|').length;">&raquo;</button>
</div>
<div class="block">
    <input type="text" id="frameInput" title="Current frame string">
</div>
<div class="block">
    <button onclick="removeFrame()" title="Delete frame">&xotime;</button>
    <button onclick="addFrame()" title="Duplicate frame">&xoplus;</button>
    <button onclick="moveFrameUp()" title="Move frame up">&uarr;</button>
    <button onclick="moveFrameDown()" title="Move frame down">&darr;</button>
</div>
<canvas id="spritesheet" class="block"></canvas>
<!--
<div class="block">
    <button id="animationBoundsLeftToLeft" title="Animation bounds left to left">&lsaquo;&lcub;</button>
    <button id="animationBoundsLeftToRight" title="Animation bounds left to right">&lcub;&rsaquo;</button>
    <button id="animationBoundsRightToLeft" title="Animation bounds right to left">&lsaquo;&rcub;</button>
    <button id="animationBoundsRightToRight" title="Animation bounds right to right">&rcub;&rsaquo;</button>
</div>
-->
<div class="block">
    <input type="number" class="small" inputmode="numeric" pattern="[0-9]*" name="frameWidth" title="Frame width">
    <input type="number" class="small" inputmode="numeric" pattern="[0-9]*" name="frameHeight" title="Frame height">
    <input type="number" class="small" inputmode="numeric" pattern="[0-9]*" name="nFramesWide" title="Horizontal number of frames in spritesheet">
    <input type="number" class="small" inputmode="numeric" pattern="[0-9]*" name="fps" title="Frames per second">
</div>
<div class="block">
    <input type="text" class="small" title="Key" value="$">
    <input type="text" class="medium" title="Color of key" value="transparent" disabled>
    <button id="addColorButton" title="Add color">&xoplus;</button>
</div>
<div id="colorBlocks">
    <div class="block">
        <input type="text" class="small" title="Key" value="a">
        <input type="text" class="medium" title="Color of key" value="teal">
        <button title="Delete color">&xotime;</button>
    </div>
</div>
<div class="block">
    <button id="importButton">import</button>
    <button onclick="copyStringToClipboard(window.location, this)">share</button>
    <button onclick="copyStringToClipboard(data.frames, this)">string</button>
    <button id="copyCodeButton">code</button>
</div>
<script>

let playing = false;
let mask = true;
spritesheet.addEventListener('contextmenu', e => {
    mask = false;
});

let frameWidth = 8;
let frameHeight = 8;
let currentFrame = 0;
let nFramesWide = 5;

let data = {
    frames: '$2a4$4a4$4a4$4a4|$10a4$4a4$4a4$4a4|$18a4$4a4$4a4$4a4|$26a4$4a4$4a4$4a4|$34a4$4a4$4a4$4a4',
    fps: 12,
    get frameWidth() {
        return frameWidth;
    },
    set frameWidth (v) {
        frameWidth = v;
        onR();
    },
    get frameHeight() {
        return frameHeight;
    },
    set frameHeight(v) {
        frameHeight = v;
        onR();
    },
    get currentFrame() {
        return currentFrame;
    },
    set currentFrame(v) {
        currentFrame = v;
        frameInput.value = this.frames.split('|')[v];
        if (!playing) {
            mask = true;
        }
    },
    get nFramesWide() {
        return nFramesWide;
    },
    set nFramesWide (v) {
        nFramesWide = v;
        document.querySelector('[name="nFramesWide"').value = nFramesWide;
        onR();
    }
};

data.currentFrame = 0;

//console.log(JSON.stringify(data));

data.colors = {
    a: 'teal'
};

Object.keys(data).forEach(key => {
    let input = document.querySelector('[name="' + key + '"');
    if (input === null) {
        return;
    }
    input.value = data[key];
    input.addEventListener('blur', e => {
        if (input.type === 'number') {
            data[key] = Number(input.value);
        } else {
            data[key] = input.value;
        }
    });
});

frameInput.addEventListener('keyup', e => {
    let frames = data.frames.split('|');
    let values = frameInput.value.split('|');
    frames.splice(currentFrame, 1, ...values);
    data.frames = frames.join('|');
    onR();
    data.currentFrame = currentFrame;
});

let removeFrame = _ => {
    let frames = data.frames.split('|');
    if (frames.length === data.nFramesWide) {
        data.nFramesWide = data.nFramesWide - 1 || 1;
    }
    frames.splice(currentFrame, 1);
    data.frames = frames.join('|');
    data.currentFrame = (currentFrame % frames.length) || 0;
    onR();
};

let addFrame = _ => {
    let frames = data.frames.split('|');
    if (frames.length === data.nFramesWide) {
        data.nFramesWide = data.nFramesWide + 1;
    }
    let newFrame = frames[currentFrame];
    frames.splice(currentFrame, 0, newFrame);
    data.frames = frames.join('|');
    data.currentFrame = currentFrame + 1;
    onR();
};

let moveFrameUp = _ => {
    let frames = data.frames.split('|');
    let newFrame = frames[currentFrame];
    frames.splice(currentFrame, 1);
    data.currentFrame = (currentFrame + 1) % (frames.length + 1);
    frames.splice(currentFrame, 0, newFrame);
    data.frames = frames.join('|');
};

let moveFrameDown = _ => {
    let frames = data.frames.split('|');
    let newFrame = frames[currentFrame];
    frames.splice(currentFrame, 1);
    data.currentFrame = (currentFrame + frames.length) % (frames.length + 1);
    frames.splice(currentFrame, 0, newFrame);
    data.frames = frames.join('|');
};

// the 2d drawing api
let ctx = canvas.getContext('2d');
//console.log(ctx);
let ctxSheet = spritesheet.getContext('2d');

// resize canvas with window
let resizeTOID = 0;
let onR = e => {
    clearTimeout(resizeTOID);
    resizeTOID = setTimeout(_ => {
        canvas.width = frameWidth;
        canvas.height = frameHeight;
        let w = Math.min(Math.floor(window.innerWidth / frameWidth), 32) * frameWidth;
        let h = w / frameWidth * frameHeight;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        // tmp
        spritesheet.width = frameWidth * nFramesWide;
        spritesheet.height = frameHeight * Math.ceil(data.frames.split('|').length / nFramesWide);
        w = Math.min(Math.floor(window.innerWidth / spritesheet.width), 8) * spritesheet.width;
        h = w / frameWidth / nFramesWide * frameHeight * Math.ceil(data.frames.split('|').length / nFramesWide);
        spritesheet.style.width = w + 'px';
        spritesheet.style.height = h + 'px';
    }, 40);
};
onR();
window.addEventListener('resize', onR);

// animation loop
let timer = 0;
let onF = time => {

    if (timer < time - 1000 / data.fps) {
        timer = time;
        if (playing) {
            data.currentFrame = (data.currentFrame + 1) % (data.frames.split('|').length);
        }
    }

    // clear canvas
    ctx.clearRect(0, 0, frameWidth, frameHeight);

    // draw stuff
    let frameData = data.frames.split('|')[currentFrame];
    if (frameData !== undefined) {
        frameData = frameData.replace(/(\D)(\d+)/g, (_, char, count) => char.repeat(count));
        [...frameData].forEach((c, i) => {
            let color = data.colors[c];
            if (color === undefined) {
                return;
            }
            let x = i % data.frameWidth;
            let y = Math.floor(i / data.frameWidth);
            ctx.fillStyle = color;
            ctx.fillRect(x, y, 1, 1);
        });
    }

    // clear spritesheet
    ctxSheet.clearRect(0, 0, spritesheet.width, spritesheet.height);
    if (mask === true) {
        ctxSheet.fillStyle = 'rgba(0, 0, 0, .35)';
        ctxSheet.fillRect(0, 0, spritesheet.width, spritesheet.height);
    }

    // draw spritesheet
    data.frames.split('|').forEach((fData, offset) => {
        ctxSheet.save();
        ctxSheet.translate((offset % data.nFramesWide) * data.frameWidth, Math.floor(offset / data.nFramesWide) * frameHeight);
        if (mask === true && offset === currentFrame) {
            ctxSheet.clearRect(0, 0, frameWidth, frameHeight);
        }
        frameData = fData.replace(/(\D)(\d+)/g, (_, char, count) => char.repeat(count));
        [...frameData].forEach((c, i) => {
            let color = data.colors[c];
            if (color === undefined) {
                return;
            }
            let x = i % data.frameWidth;
            let y = Math.floor(i / data.frameWidth);
            ctxSheet.fillStyle = color;
            ctxSheet.fillRect(x, y, 1, 1);
        });
        ctxSheet.restore();
    });

    // request next frame
    requestAnimationFrame(onF);
};
setTimeout(onF, 50, 0);

// register service worker for PWA
if ('serviceWorker' in navigator) {
    window.addEventListener('load', e => {
        navigator.serviceWorker.register('./sw.js').then(registration => {
            //console.log('ServiceWorker registration successful with scope: ', registration.scope);
        }, err => {
            //console.log('ServiceWorker registration failed: ', err);
        });
    });
}

let copyStringToClipboard = (str, target) => {
   let oldHtml = target.innerHTML;
   target.innerHTML = 'Copied!';
   let el = document.createElement('textarea');
   el.value = str;
   el.setAttribute('readonly', '');
   el.style = {position: 'absolute', left: '-9999px'};
   document.body.appendChild(el);
   el.select();
   document.execCommand('copy');
   document.body.removeChild(el);
   setTimeout(_ => {
        target.innerHTML = oldHtml;
   }, 2000);
}

</script>
</body>
</html>
